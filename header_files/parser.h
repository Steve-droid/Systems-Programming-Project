/**
 * @file parser.h
 * @brief Header file for the syntax analyzer (parser) component of the assembly code translator.
 *
 * The parser (syntax analyzer) is a crucial component in the process of translating
 * the made-up assembly-like code into machine code or another target format.
 * This file contains the declarations and definitions for the parser component.
 *
 * The primary role of the parser is to:
 * - Read the stream of tokens generated by the lexer.
 * - Analyze the token sequence according to the grammatical rules of the assembly-like language.
 * - Construct a parse tree or abstract syntax tree (AST) that represents the hierarchical structure of the source code.
 * - Ensure that the token sequence forms a syntactically valid program.
 * - Report syntactic errors, such as unexpected tokens or missing operators.
 *
 * The parser transforms the flat sequence of tokens into a structured representation
 * that reflects the logical and syntactic organization of the code, facilitating further stages of translation.
 */


#ifndef PARSER_H
#define PARSER_H

#include "common.h"
#include "label.h"
#include "keyword.h"
#include "util.h"
#include "lexer.h"

int *proccess_assembly_code(char *am_filename, label_table *_label_table, keyword *keyword_table);

/**
 * @brief Processes a line of assembly code and fills the pre_decoded array with command fields when the number of fields is known.
 *
 * This function handles the processing of command fields in a line of assembly code, specifically for commands where the number of fields
 * is predetermined. It performs the following steps:
 * - Loops through the expected number of fields, extracting and storing each field in the pre_decoded array.
 * - Validates the format of each field, ensuring there are no errors such as missing commas or invalid characters.
 * - Checks for common errors such as too many or too few fields, invalid symbols, and misplaced commas.
 *
 * @param line The line of assembly code to process.
 * @param pre_decoded The array to store the command's fields.
 * @param pre_decoded_size The number of fields expected for the command.
 * @param _label_table The table containing label information.
 * @return A status indicating success (true) or failure (false) of the operation.
 */
int process_fields_for_known_amount(char *line, string *pre_decoded, int pre_decoded_size, label_table *_label_table);

/**
 * @brief Processes a line of assembly code and fills the pre_decoded array with command fields when the number of fields is unknown.
 *
 * This function handles the processing of command fields in a line of assembly code, specifically for commands where the number of fields
 * is not predetermined. It processes `.data`, `.string`, `.entry`, and `.extern` commands, performing validation and filling the pre_decoded array
 * with the fields.
 *
 * The steps include:
 * - Skipping unnecessary spaces and labels in the line.
 * - Handling and validating the format for `.data` and `.string` commands.
 * - Checking for invalid symbols and ensuring proper comma placement for `.data` commands.
 * - Ensuring proper use of quotation marks for `.string` commands.
 * - Handling label-related commands (`.entry` and `.extern`), updating the label table accordingly.
 *
 * @param line The line of assembly code to process.
 * @param command_number The command number indicating which command is being processed.
 * @param keyword_table The table containing keyword information.
 * @param pre_decoded The array to store the command's fields.
 * @param _label_table The table containing label information.
 * @return A status indicating success (true) or failure (false) of the operation.
 */
int process_fields_for_unknown_amount(char *line, int command_number, keyword *keyword_table, string *pre_decoded, label_table *_label_table);

/**
 * @brief Fills the pre_decoded array with the command and its arguments from a given line of assembly code.
 *
 * This function processes a line of assembly code to populate the pre_decoded array with the command
 * and its arguments. It performs the following steps:
 * - Identifies the command and stores it as the first element in the pre_decoded array.
 * - Skips any labels and leading spaces in the line.
 * - Checks for and handles unnecessary commas between the command and arguments.
 * - Fills the remaining elements of the pre_decoded array with the command's arguments, handling both known and unknown numbers of arguments.
 *
 * @param line The line of assembly code to process.
 * @param pre_decoded The array to store the command and its arguments.
 * @param pre_decoded_size The number of arguments expected for the command.
 * @param keyword_table The table containing keyword information.
 * @param command_name_key The key of the command in the keyword table.
 * @param _label_table The table containing label information.
 * @param current_line The current line number being processed.
 * @return A status indicating success (true) or failure (false) of the operation.
 */
int fill_pre_decoded_array(char *line, string *pre_decoded, int pre_decoded_size, keyword *keyword_table, int command_name_key, label_table *_label_table, int current_line);

/**
 * @brief Validates the data of a known argument by mapping it to an addressing method.
 *
 * This function checks if the provided argument data is valid by mapping it to an addressing method
 * using the label table. It verifies whether the argument matches any of the known addressing methods
 * (0, 1, 2, or 3).
 *
 * @param str The argument data to validate.
 * @param _label_table The table containing label information.
 * @return True if the argument data is valid, false otherwise.
 */
bool validate_known_argument_data(char *str, label_table *_label_table);

/**
 * @brief Checks if the addressing methods used in a binary command are legal.
 *
 * This function validates the addressing methods for both the source and destination
 * in a binary command based on the command key using the keyword table.
 *
 * @param binary_command The binary representation of the command.
 * @param keyword_table The table containing keyword information.
 * @param key The key of the command to validate.
 * @return True if both the source and destination addressing methods are legal, false otherwise.
 */
bool validate_addressing_methods(int *binary_command, keyword *keyword_table, int key);

/**
 * @brief Checks if the source addressing methods used in a binary command are legal.
 *
 * This function validates the source addressing methods in a binary command based on the command key
 * using the keyword table. It ensures that the addressing methods are appropriate for the specified command.
 *
 * @param binary_command The binary representation of the command.
 * @param keyword_table The table containing keyword information.
 * @param key The key of the command to validate.
 * @return True if the source addressing methods are legal, false otherwise.
 */
bool validate_source_argument_addressing(int *binary_command, keyword *keyword_table, int key);

/**
 * @brief Checks if the destination addressing methods used in a binary command are legal.
 *
 * This function validates the destination addressing methods in a binary command based on the command key
 * using the keyword table. It ensures that the addressing methods are appropriate for the specified command.
 *
 * @param binary_command The binary representation of the command.
 * @param keyword_table The table containing keyword information.
 * @param key The key of the command to validate.
 * @return True if the destination addressing methods are legal, false otherwise.
 */
bool validate_destination_argument_addressing(int *binary_command, keyword *keyword_table, int key);


/**
 *@brief Get a field in an instruction and return the addressing method of the arguments in the fields
 *
 * @param str The ins
 * @param label_table
 * @return int
 */
 /**
  *@brief Get a field in an instruction and return the addressing method of the arguments in the fields
  *
  * @param str The ins
  * @param label_table
  * @return int
  */
int get_addressing_method(char *str, label_table *_label_table);

#endif